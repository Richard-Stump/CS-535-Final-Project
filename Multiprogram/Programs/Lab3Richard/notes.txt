

Wireframe Rendering:
 - GS registers:
    - 00h:
            Primitive set to line
            rest of the registers are off
    - 1ah:  Set to zero since we don't wna to use primitive mode register
    - 01h: 

gskick:
    The gskick instruction takes a register holding the address to a preconstructed GIF packet?
    
EE Program:
    1) Upload microprogram for vu1
    2) Load vertex data from CD, converting triangles to lines
    3) Send the vertex data over to the VPU 1's data memory
    4) Main loop:
        a) Swap buffers?
        b) Construct instance data buffer
        c) send instance data buffer over to the VU1
        d) begin microprogram
        e) Perform game updates

VU1 program:
    1) Load proj-view matrix
    2) For each item in the instance list
        a) Load the transformatation matrix
        b) Left multiply the transformation by the proj-view to get the final world transform
        c) Load the mesh id
        d) For each triangle in the mesh
            i)      transform the 3 vertices
            ii)     break the 3 vertices into 3 lines
            iii)    store the lines in the output buffer
            iv)     set the color of the verts
    3) Kick the data to the GS

VU1 Data Memory Layout:
    0)      Mesh data for playfield
    1)      Mesh data for bullet
    2)      Mesh data for powerup
    3)      Mesh data for enemy
    4)      Instance data?
    5)      Program parameters

    
Ideas to consider:
 * Store the color information with the models
 * Instanced rendering:
    Have another buffer stored on the VU1 where each element has the following structure:
            0) Transformation Matrix
            1) Mesh ID to use

General pipeline notes:
 * XTOP instruction fetches the data from the TOP register
 * TOP register contains the address for program parameters. I think this is so that the code for VU1 programs becomes
   more independent from memory locations. If so, why does the example place the transformation matrix at address 0?
   Is it because it would be used by all programs?
 * It appears the EE controls the system and informs VU1 where to place everything in memory, which makes sense.
   You want the VU1 to spend all of its time transforming data while the EE can do other things
 * In the example, the memory block starting where the TOP register contains things like where the vertex data is placed
   in memory, where the transformed data should be sent, the GIF packet? etc.

Things to change for porting:
X    1) Change the mesh loading code to load from the disc
    2) Change the mesh loading code to convert the triangles to tris
    3) Change the keyboard input to use the gamepad
    4) Change the rendering code to send instance lists

EE Program V2:
    1) Intialize the system
        a) Set resolution, misc. screen information
        b) Set up GS to display lines

    2) Upload the vu1 program
        a) Get the pointer to the vu1 section in the elf
        b) send it to address 0 of the vu1 micro memory

    3) Load meshes:
        a) Load them from the disc, converting tris to lines (this eases the work of the microprogram)
        b) Upload them to the data memory of VU1

    3) Initialize Game state
        a) should be the same as the initial lab 3
        b) Hardcode resolution sent to the application
        c) 

    4) Main loop
        a) Get gamepad input
        b) Calculate change in time (Maybe hardcode this)
        c) Render
            1) Generate instance list for the 
        d) Swap buffers (maybe forget this step) and wait for the vu1 to finish


VU1 layout (From xtop)
    0) Scale x, scale y, scale z, vertex count
    1) Gif Set
    2) Gif primitive
    3) Color
    4) Matrix row 0
    5) matrix row 1
    6) matrix row 2
    7) matrix row 3